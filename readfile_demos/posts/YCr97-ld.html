<p>留着备用。</p>
<p>&ldquo;first-in largest-out&rdquo;最大优先队列：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">&lt;!</span><span style="color: #ff00ff;">DOCTYPE html</span><span style="color: #0000ff;">&gt;</span>
<span style="color: #0000ff;">&lt;</span><span style="color: #800000;">html</span><span style="color: #0000ff;">&gt;</span>
    <span style="color: #0000ff;">&lt;</span><span style="color: #800000;">head</span><span style="color: #0000ff;">&gt;</span>
        <span style="color: #0000ff;">&lt;</span><span style="color: #800000;">meta </span><span style="color: #ff0000;">charset</span><span style="color: #0000ff;">="UTF-8"</span><span style="color: #0000ff;">&gt;</span>
        <span style="color: #0000ff;">&lt;</span><span style="color: #800000;">title</span><span style="color: #0000ff;">&gt;&lt;/</span><span style="color: #800000;">title</span><span style="color: #0000ff;">&gt;</span>
    <span style="color: #0000ff;">&lt;/</span><span style="color: #800000;">head</span><span style="color: #0000ff;">&gt;</span>
    <span style="color: #0000ff;">&lt;</span><span style="color: #800000;">body</span><span style="color: #0000ff;">&gt;</span>        
        <span style="color: #0000ff;">&lt;</span><span style="color: #800000;">script </span><span style="color: #ff0000;">type</span><span style="color: #0000ff;">="text/javascript"</span><span style="color: #0000ff;">&gt;</span><span style="background-color: #f5f5f5; color: #000000;">
            class PriorityQueue {
                constructor() {
                    </span><span style="background-color: #f5f5f5; color: #0000ff;">this</span><span style="background-color: #f5f5f5; color: #000000;">.A </span><span style="background-color: #f5f5f5; color: #000000;">=</span><span style="background-color: #f5f5f5; color: #000000;"> [];
                    Heap.buildMaxHeap(</span><span style="background-color: #f5f5f5; color: #0000ff;">this</span><span style="background-color: #f5f5f5; color: #000000;">.A);                
                }
                
                isEmpty() {
                    </span><span style="background-color: #f5f5f5; color: #0000ff;">return</span> <span style="background-color: #f5f5f5; color: #0000ff;">this</span><span style="background-color: #f5f5f5; color: #000000;">.A.heapSize </span><span style="background-color: #f5f5f5; color: #000000;">==</span> <span style="background-color: #f5f5f5; color: #000000;">0</span><span style="background-color: #f5f5f5; color: #000000;">;
                }
                
                insertWithPriority(x, priority) {
                    </span><span style="background-color: #f5f5f5; color: #0000ff;">this</span><span style="background-color: #f5f5f5; color: #000000;">.A.heapSize </span><span style="background-color: #f5f5f5; color: #000000;">+=</span> <span style="background-color: #f5f5f5; color: #000000;">1</span><span style="background-color: #f5f5f5; color: #000000;">;
                    </span><span style="background-color: #f5f5f5; color: #0000ff;">this</span><span style="background-color: #f5f5f5; color: #000000;">.A[</span><span style="background-color: #f5f5f5; color: #0000ff;">this</span><span style="background-color: #f5f5f5; color: #000000;">.A.heapSize] </span><span style="background-color: #f5f5f5; color: #000000;">=</span><span style="background-color: #f5f5f5; color: #000000;"> {
                        x: x,
                        priority: </span><span style="background-color: #f5f5f5; color: #000000;">-</span><span style="background-color: #f5f5f5; color: #000000;">Infinity
                    };
                    Heap.increasePriority(</span><span style="background-color: #f5f5f5; color: #0000ff;">this</span><span style="background-color: #f5f5f5; color: #000000;">.A, </span><span style="background-color: #f5f5f5; color: #0000ff;">this</span><span style="background-color: #f5f5f5; color: #000000;">.A.heapSize, priority);
                }
                
                pullHighestPriorityElement() {
                    </span><span style="background-color: #f5f5f5; color: #0000ff;">if</span><span style="background-color: #f5f5f5; color: #000000;"> (</span><span style="background-color: #f5f5f5; color: #0000ff;">this</span><span style="background-color: #f5f5f5; color: #000000;">.A.heapSize </span><span style="background-color: #f5f5f5; color: #000000;">==</span> <span style="background-color: #f5f5f5; color: #000000;">0</span><span style="background-color: #f5f5f5; color: #000000;">) {
                        </span><span style="background-color: #f5f5f5; color: #0000ff;">return</span> <span style="background-color: #f5f5f5; color: #0000ff;">null</span><span style="background-color: #f5f5f5; color: #000000;">;
                    } </span><span style="background-color: #f5f5f5; color: #0000ff;">else</span><span style="background-color: #f5f5f5; color: #000000;"> {
                        </span><span style="background-color: #f5f5f5; color: #0000ff;">return</span><span style="background-color: #f5f5f5; color: #000000;"> Heap.extractMax(</span><span style="background-color: #f5f5f5; color: #0000ff;">this</span><span style="background-color: #f5f5f5; color: #000000;">.A).x;
                    }
                }
                
                peek() {
                    </span><span style="background-color: #f5f5f5; color: #0000ff;">return</span> <span style="background-color: #f5f5f5; color: #0000ff;">this</span><span style="background-color: #f5f5f5; color: #000000;">.A[</span><span style="background-color: #f5f5f5; color: #000000;">1</span><span style="background-color: #f5f5f5; color: #000000;">].x;
                }
            }
        </span><span style="color: #0000ff;">&lt;/</span><span style="color: #800000;">script</span><span style="color: #0000ff;">&gt;</span>
        
        <span style="color: #0000ff;">&lt;</span><span style="color: #800000;">script </span><span style="color: #ff0000;">type</span><span style="color: #0000ff;">="text/javascript"</span><span style="color: #0000ff;">&gt;</span>
            <span style="background-color: #f5f5f5; color: #008000;">//</span><span style="background-color: #f5f5f5; color: #008000;"> 改进版本2，专门用来写优先队列。</span>
            <span style="background-color: #f5f5f5; color: #008000;">//</span><span style="background-color: #f5f5f5; color: #008000;"> 每个数组元素有两个属性：x和priority，后者决定位置，前者是实际存储的内容</span>
<span style="background-color: #f5f5f5; color: #000000;">            class Heap {
                </span><span style="background-color: #f5f5f5; color: #008000;">//</span><span style="background-color: #f5f5f5; color: #008000;"> 把数组A转化为最大堆</span>
<span style="background-color: #f5f5f5; color: #000000;">                static buildMaxHeap(A) {
                    A.unshift(undefined); </span><span style="background-color: #f5f5f5; color: #008000;">//</span><span style="background-color: #f5f5f5; color: #008000;"> 便于后续的下标计算</span>
<span style="background-color: #f5f5f5; color: #000000;">                    
                    A.heapSize </span><span style="background-color: #f5f5f5; color: #000000;">=</span><span style="background-color: #f5f5f5; color: #000000;"> A.length </span><span style="background-color: #f5f5f5; color: #000000;">-</span> <span style="background-color: #f5f5f5; color: #000000;">1</span><span style="background-color: #f5f5f5; color: #000000;">; </span><span style="background-color: #f5f5f5; color: #008000;">//</span><span style="background-color: #f5f5f5; color: #008000;"> 实际多存了一个undefined</span>
                    <span style="background-color: #f5f5f5; color: #0000ff;">for</span><span style="background-color: #f5f5f5; color: #000000;"> (let i </span><span style="background-color: #f5f5f5; color: #000000;">=</span><span style="background-color: #f5f5f5; color: #000000;"> Math.floor(A.heapSize </span><span style="background-color: #f5f5f5; color: #000000;">/</span> <span style="background-color: #f5f5f5; color: #000000;">2</span><span style="background-color: #f5f5f5; color: #000000;">); i </span><span style="background-color: #f5f5f5; color: #000000;">&gt;=</span> <span style="background-color: #f5f5f5; color: #000000;">1</span><span style="background-color: #f5f5f5; color: #000000;">; </span><span style="background-color: #f5f5f5; color: #000000;">--</span><span style="background-color: #f5f5f5; color: #000000;">i) {
                        </span><span style="background-color: #f5f5f5; color: #008000;">//</span><span style="background-color: #f5f5f5; color: #008000;"> 对所有非叶结点调用一次maxHeapify</span>
                        <span style="background-color: #f5f5f5; color: #008000;">//</span><span style="background-color: #f5f5f5; color: #008000;"> 之所以下标从后往前，是因为maxHeapify假定调用结点的左右子树都已经为最大堆</span>
                        <span style="background-color: #f5f5f5; color: #008000;">//</span><span style="background-color: #f5f5f5; color: #008000;"> 单个元素（叶结点）很自然地是一个最大堆</span>
<span style="background-color: #f5f5f5; color: #000000;">                        Heap.maxHeapify(A, i);
                    }
                }
                
                </span><span style="background-color: #f5f5f5; color: #008000;">//</span><span style="background-color: #f5f5f5; color: #008000;"> 维护堆的性质</span>
<span style="background-color: #f5f5f5; color: #000000;">                static maxHeapify(A, i) {
                    let l </span><span style="background-color: #f5f5f5; color: #000000;">=</span><span style="background-color: #f5f5f5; color: #000000;"> Heap.left(i);
                    let r </span><span style="background-color: #f5f5f5; color: #000000;">=</span><span style="background-color: #f5f5f5; color: #000000;"> Heap.right(i);
                    
                    let largest </span><span style="background-color: #f5f5f5; color: #000000;">=</span><span style="background-color: #f5f5f5; color: #000000;"> i;
                    </span><span style="background-color: #f5f5f5; color: #008000;">//</span><span style="background-color: #f5f5f5; color: #008000;"> maxHeapify假定调用结点的左右子树都已经为最大堆</span>
                    <span style="background-color: #f5f5f5; color: #008000;">//</span><span style="background-color: #f5f5f5; color: #008000;"> 只是把调用结点i放到恰当的位置，以维护堆的性质</span>
                    <span style="background-color: #f5f5f5; color: #0000ff;">if</span><span style="background-color: #f5f5f5; color: #000000;"> (l </span><span style="background-color: #f5f5f5; color: #000000;">&lt;=</span><span style="background-color: #f5f5f5; color: #000000;"> A.heapSize </span><span style="background-color: #f5f5f5; color: #000000;">&amp;&amp;</span><span style="background-color: #f5f5f5; color: #000000;"> A[l].priority </span><span style="background-color: #f5f5f5; color: #000000;">&gt;</span><span style="background-color: #f5f5f5; color: #000000;"> A[i].priority) {
                        largest </span><span style="background-color: #f5f5f5; color: #000000;">=</span><span style="background-color: #f5f5f5; color: #000000;"> l;
                    }
                    
                    </span><span style="background-color: #f5f5f5; color: #0000ff;">if</span><span style="background-color: #f5f5f5; color: #000000;"> (r </span><span style="background-color: #f5f5f5; color: #000000;">&lt;=</span><span style="background-color: #f5f5f5; color: #000000;"> A.heapSize </span><span style="background-color: #f5f5f5; color: #000000;">&amp;&amp;</span><span style="background-color: #f5f5f5; color: #000000;"> A[r].priority </span><span style="background-color: #f5f5f5; color: #000000;">&gt;</span><span style="background-color: #f5f5f5; color: #000000;"> A[largest].priority) {
                        largest </span><span style="background-color: #f5f5f5; color: #000000;">=</span><span style="background-color: #f5f5f5; color: #000000;"> r;
                    }
                    
                    </span><span style="background-color: #f5f5f5; color: #0000ff;">if</span><span style="background-color: #f5f5f5; color: #000000;"> (largest </span><span style="background-color: #f5f5f5; color: #000000;">!=</span><span style="background-color: #f5f5f5; color: #000000;"> i) {
                        let temp </span><span style="background-color: #f5f5f5; color: #000000;">=</span><span style="background-color: #f5f5f5; color: #000000;"> A[i];
                        A[i] </span><span style="background-color: #f5f5f5; color: #000000;">=</span><span style="background-color: #f5f5f5; color: #000000;"> A[largest];
                        A[largest] </span><span style="background-color: #f5f5f5; color: #000000;">=</span><span style="background-color: #f5f5f5; color: #000000;"> temp;
                        
                        Heap.maxHeapify(A, largest);
                    }
                }
                
                static left(i) {
                    </span><span style="background-color: #f5f5f5; color: #0000ff;">return</span> <span style="background-color: #f5f5f5; color: #000000;">2</span> <span style="background-color: #f5f5f5; color: #000000;">*</span><span style="background-color: #f5f5f5; color: #000000;"> i;
                }
                
                static right(i) {
                    </span><span style="background-color: #f5f5f5; color: #0000ff;">return</span> <span style="background-color: #f5f5f5; color: #000000;">2</span> <span style="background-color: #f5f5f5; color: #000000;">*</span><span style="background-color: #f5f5f5; color: #000000;"> i </span><span style="background-color: #f5f5f5; color: #000000;">+</span> <span style="background-color: #f5f5f5; color: #000000;">1</span><span style="background-color: #f5f5f5; color: #000000;">;
                }
                
                static parent(i) {
                    </span><span style="background-color: #f5f5f5; color: #0000ff;">return</span><span style="background-color: #f5f5f5; color: #000000;"> Math.floor(i </span><span style="background-color: #f5f5f5; color: #000000;">/</span> <span style="background-color: #f5f5f5; color: #000000;">2</span><span style="background-color: #f5f5f5; color: #000000;">);
                }
                
                static extractMax(A) {
                    </span><span style="background-color: #f5f5f5; color: #0000ff;">if</span><span style="background-color: #f5f5f5; color: #000000;"> (A.heapSize </span><span style="background-color: #f5f5f5; color: #000000;">&lt;</span> <span style="background-color: #f5f5f5; color: #000000;">1</span><span style="background-color: #f5f5f5; color: #000000;">) </span><span style="background-color: #f5f5f5; color: #0000ff;">return</span> <span style="background-color: #f5f5f5; color: #0000ff;">null</span><span style="background-color: #f5f5f5; color: #000000;">;
                    
                    let max </span><span style="background-color: #f5f5f5; color: #000000;">=</span><span style="background-color: #f5f5f5; color: #000000;"> A[</span><span style="background-color: #f5f5f5; color: #000000;">1</span><span style="background-color: #f5f5f5; color: #000000;">];
                    A[</span><span style="background-color: #f5f5f5; color: #000000;">1</span><span style="background-color: #f5f5f5; color: #000000;">] </span><span style="background-color: #f5f5f5; color: #000000;">=</span><span style="background-color: #f5f5f5; color: #000000;"> A[A.heapSize];
                    A.heapSize </span><span style="background-color: #f5f5f5; color: #000000;">=</span><span style="background-color: #f5f5f5; color: #000000;"> A.heapSize </span><span style="background-color: #f5f5f5; color: #000000;">-</span> <span style="background-color: #f5f5f5; color: #000000;">1</span><span style="background-color: #f5f5f5; color: #000000;">;
                    
                    Heap.maxHeapify(A, </span><span style="background-color: #f5f5f5; color: #000000;">1</span><span style="background-color: #f5f5f5; color: #000000;">);
                    
                    </span><span style="background-color: #f5f5f5; color: #0000ff;">return</span><span style="background-color: #f5f5f5; color: #000000;"> max;
                }
                
                static increasePriority(A, i, newPriority) {
                    </span><span style="background-color: #f5f5f5; color: #0000ff;">if</span><span style="background-color: #f5f5f5; color: #000000;"> (newPriority </span><span style="background-color: #f5f5f5; color: #000000;">&lt;</span><span style="background-color: #f5f5f5; color: #000000;"> A[i].priority) {
                        </span><span style="background-color: #f5f5f5; color: #0000ff;">return</span><span style="background-color: #f5f5f5; color: #000000;">;
                    }
                    A[i].priority </span><span style="background-color: #f5f5f5; color: #000000;">=</span><span style="background-color: #f5f5f5; color: #000000;"> newPriority;
                    </span><span style="background-color: #f5f5f5; color: #0000ff;">while</span><span style="background-color: #f5f5f5; color: #000000;"> (i </span><span style="background-color: #f5f5f5; color: #000000;">&gt;</span> <span style="background-color: #f5f5f5; color: #000000;">1</span> <span style="background-color: #f5f5f5; color: #000000;">&amp;&amp;</span><span style="background-color: #f5f5f5; color: #000000;"> A[Heap.parent(i)].priority </span><span style="background-color: #f5f5f5; color: #000000;">&lt;</span><span style="background-color: #f5f5f5; color: #000000;"> A[i].priority) {
                        let temp </span><span style="background-color: #f5f5f5; color: #000000;">=</span><span style="background-color: #f5f5f5; color: #000000;"> A[i];
                        A[i] </span><span style="background-color: #f5f5f5; color: #000000;">=</span><span style="background-color: #f5f5f5; color: #000000;"> A[Heap.parent(i)];
                        A[Heap.parent(i)] </span><span style="background-color: #f5f5f5; color: #000000;">=</span><span style="background-color: #f5f5f5; color: #000000;"> temp;    
                        
                        i </span><span style="background-color: #f5f5f5; color: #000000;">=</span><span style="background-color: #f5f5f5; color: #000000;"> Heap.parent(i);
                    }
                }
            }
        </span><span style="color: #0000ff;">&lt;/</span><span style="color: #800000;">script</span><span style="color: #0000ff;">&gt;</span>

<strong>        <span style="color: #0000ff;">&lt;</span><span style="color: #800000;">script </span><span style="color: #ff0000;">type</span><span style="color: #0000ff;">="text/javascript"</span><span style="color: #0000ff;">&gt;</span><span style="background-color: #f5f5f5; color: #000000;">
            let pQ </span><span style="background-color: #f5f5f5; color: #000000;">=</span> <span style="background-color: #f5f5f5; color: #0000ff;">new</span><span style="background-color: #f5f5f5; color: #000000;"> PriorityQueue();
            console.log(pQ.isEmpty());
            pQ.insertWithPriority(</span><span style="background-color: #f5f5f5; color: #000000;">"</span><span style="background-color: #f5f5f5; color: #000000;">employee</span><span style="background-color: #f5f5f5; color: #000000;">"</span><span style="background-color: #f5f5f5; color: #000000;">, </span><span style="background-color: #f5f5f5; color: #000000;">15</span><span style="background-color: #f5f5f5; color: #000000;">);
            console.log(pQ.isEmpty());
            pQ.insertWithPriority(</span><span style="background-color: #f5f5f5; color: #000000;">"</span><span style="background-color: #f5f5f5; color: #000000;">boss</span><span style="background-color: #f5f5f5; color: #000000;">"</span><span style="background-color: #f5f5f5; color: #000000;">, </span><span style="background-color: #f5f5f5; color: #000000;">25</span><span style="background-color: #f5f5f5; color: #000000;">);
            console.log(pQ.peek());
            console.log(pQ.pullHighestPriorityElement());
            console.log(pQ.pullHighestPriorityElement());
            </span><span style="background-color: #f5f5f5; color: #008000;">/*</span><span style="background-color: #f5f5f5; color: #008000;">*
             * output=
             * true
             * false
             * boss
             * boss
             * employee
             </span><span style="background-color: #f5f5f5; color: #008000;">*/</span>
        <span style="color: #0000ff;">&lt;/</span><span style="color: #800000;">script</span><span style="color: #0000ff;">&gt;</span></strong>
    <span style="color: #0000ff;">&lt;/</span><span style="color: #800000;">body</span><span style="color: #0000ff;">&gt;</span>
<span style="color: #0000ff;">&lt;/</span><span style="color: #800000;">html</span><span style="color: #0000ff;">&gt;</span></pre>
</div>
<p>&nbsp;便于copy版最大优先队列：</p>
<div class="cnblogs_code" onclick="cnblogs_code_show('2c4d140d-ac52-4711-9ddc-a03729a2a942')"><img id="code_img_closed_2c4d140d-ac52-4711-9ddc-a03729a2a942" class="code_img_closed" src="http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_2c4d140d-ac52-4711-9ddc-a03729a2a942" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('2c4d140d-ac52-4711-9ddc-a03729a2a942',event)" src="http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_2c4d140d-ac52-4711-9ddc-a03729a2a942" class="cnblogs_code_hide">
<pre><span style="color: #000000;">class PriorityQueue {
    constructor() {
        </span><span style="color: #0000ff;">this</span>.A =<span style="color: #000000;"> [];
        Heap.buildMaxHeap(</span><span style="color: #0000ff;">this</span><span style="color: #000000;">.A);
    }

    isEmpty() {
        </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">this</span>.A.heapSize == 0<span style="color: #000000;">;
    }

    insertWithPriority(x, priority) {
        </span><span style="color: #0000ff;">this</span>.A.heapSize += 1<span style="color: #000000;">;
        </span><span style="color: #0000ff;">this</span>.A[<span style="color: #0000ff;">this</span>.A.heapSize] =<span style="color: #000000;"> {
            x: x,
            priority: </span>-<span style="color: #000000;">Infinity
        };
        Heap.increasePriority(</span><span style="color: #0000ff;">this</span>.A, <span style="color: #0000ff;">this</span><span style="color: #000000;">.A.heapSize, priority);
    }

    pullHighestPriorityElement() {
        </span><span style="color: #0000ff;">if</span>(<span style="color: #0000ff;">this</span>.A.heapSize == 0<span style="color: #000000;">) {
            </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">null</span><span style="color: #000000;">;
        } </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
            </span><span style="color: #0000ff;">return</span> Heap.extractMax(<span style="color: #0000ff;">this</span><span style="color: #000000;">.A).x;
        }
    }

    peek() {
        </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">this</span>.A[1<span style="color: #000000;">].x;
    }
}

</span><span style="color: #008000;">//</span><span style="color: #008000;"> 改进版本2，专门用来写优先队列。</span><span style="color: #008000;">
//</span><span style="color: #008000;"> 每个数组元素有两个属性：x和priority，后者决定位置，前者是实际存储的内容</span>
<span style="color: #000000;">class Heap {
    </span><span style="color: #008000;">//</span><span style="color: #008000;"> 把数组A转化为最大堆</span>
<span style="color: #000000;">    static buildMaxHeap(A) {
        A.unshift(undefined); </span><span style="color: #008000;">//</span><span style="color: #008000;"> 便于后续的下标计算</span>
<span style="color: #000000;">
        A.heapSize </span>= A.length - 1; <span style="color: #008000;">//</span><span style="color: #008000;"> 实际多存了一个undefined</span>
        <span style="color: #0000ff;">for</span>(let i = Math.floor(A.heapSize / 2); i &gt;= 1; --<span style="color: #000000;">i) {
            </span><span style="color: #008000;">//</span><span style="color: #008000;"> 对所有非叶结点调用一次maxHeapify</span>
            <span style="color: #008000;">//</span><span style="color: #008000;"> 之所以下标从后往前，是因为maxHeapify假定调用结点的左右子树都已经为最大堆</span>
            <span style="color: #008000;">//</span><span style="color: #008000;"> 单个元素（叶结点）很自然地是一个最大堆</span>
<span style="color: #000000;">            Heap.maxHeapify(A, i);
        }
    }

    </span><span style="color: #008000;">//</span><span style="color: #008000;"> 维护堆的性质</span>
<span style="color: #000000;">    static maxHeapify(A, i) {
        let l </span>=<span style="color: #000000;"> Heap.left(i);
        let r </span>=<span style="color: #000000;"> Heap.right(i);

        let largest </span>=<span style="color: #000000;"> i;
        </span><span style="color: #008000;">//</span><span style="color: #008000;"> maxHeapify假定调用结点的左右子树都已经为最大堆</span>
        <span style="color: #008000;">//</span><span style="color: #008000;"> 只是把调用结点i放到恰当的位置，以维护堆的性质</span>
        <span style="color: #0000ff;">if</span>(l &lt;= A.heapSize &amp;&amp; A[l].priority &gt;<span style="color: #000000;"> A[i].priority) {
            largest </span>=<span style="color: #000000;"> l;
        }

        </span><span style="color: #0000ff;">if</span>(r &lt;= A.heapSize &amp;&amp; A[r].priority &gt;<span style="color: #000000;"> A[largest].priority) {
            largest </span>=<span style="color: #000000;"> r;
        }

        </span><span style="color: #0000ff;">if</span>(largest !=<span style="color: #000000;"> i) {
            let temp </span>=<span style="color: #000000;"> A[i];
            A[i] </span>=<span style="color: #000000;"> A[largest];
            A[largest] </span>=<span style="color: #000000;"> temp;

            Heap.maxHeapify(A, largest);
        }
    }

    static left(i) {
        </span><span style="color: #0000ff;">return</span> 2 *<span style="color: #000000;"> i;
    }

    static right(i) {
        </span><span style="color: #0000ff;">return</span> 2 * i + 1<span style="color: #000000;">;
    }

    static parent(i) {
        </span><span style="color: #0000ff;">return</span> Math.floor(i / 2<span style="color: #000000;">);
    }

    static extractMax(A) {
        </span><span style="color: #0000ff;">if</span>(A.heapSize &lt; 1) <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">null</span><span style="color: #000000;">;

        let max </span>= A[1<span style="color: #000000;">];
        A[</span>1] =<span style="color: #000000;"> A[A.heapSize];
        A.heapSize </span>= A.heapSize - 1<span style="color: #000000;">;

        Heap.maxHeapify(A, </span>1<span style="color: #000000;">);

        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> max;
    }

    static increasePriority(A, i, newPriority) {
        </span><span style="color: #0000ff;">if</span>(newPriority &lt;<span style="color: #000000;"> A[i].priority) {
            </span><span style="color: #0000ff;">return</span><span style="color: #000000;">;
        }

        let temp </span>= A[i]; <span style="color: #008000;">//</span><span style="color: #008000;"> 待插入元素</span>
        temp.priority =<span style="color: #000000;"> newPriority;
        </span><span style="color: #0000ff;">while</span>(i &gt; 1 &amp;&amp; A[Heap.parent(i)].priority &lt;<span style="color: #000000;"> newPriority) {
            A[i] </span>=<span style="color: #000000;"> A[Heap.parent(i)];
            i </span>=<span style="color: #000000;"> Heap.parent(i);
        } </span><span style="color: #008000;">//</span><span style="color: #008000;"> 寻找合适的插入位置</span>
        A[i] = temp; <span style="color: #008000;">//</span><span style="color: #008000;"> 插入元素</span>
<span style="color: #000000;">    }
}</span></pre>
</div>
<span class="cnblogs_code_collapse">View Code</span></div>
<p>&nbsp;最小优先队列（可以用在huffman编码中）：</p>
<div class="cnblogs_code" onclick="cnblogs_code_show('0bd38f9b-37be-442e-94b7-d6e31e53de50')"><img id="code_img_closed_0bd38f9b-37be-442e-94b7-d6e31e53de50" class="code_img_closed" src="http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_0bd38f9b-37be-442e-94b7-d6e31e53de50" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('0bd38f9b-37be-442e-94b7-d6e31e53de50',event)" src="http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_0bd38f9b-37be-442e-94b7-d6e31e53de50" class="cnblogs_code_hide">
<pre><span style="color: #008000;">//</span><span style="color: #008000;"> 最小优先队列</span>
<span style="color: #000000;">class PriorityQueue {
    constructor() {
        </span><span style="color: #0000ff;">this</span>.A =<span style="color: #000000;"> [];
        Heap.buildMinHeap(</span><span style="color: #0000ff;">this</span><span style="color: #000000;">.A);
    }

    isEmpty() {
        </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">this</span>.A.heapSize == 0<span style="color: #000000;">;
    }
    
    size() {
        </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">this</span><span style="color: #000000;">.A.heapSize;
    }

    insertWithPriority(x, priority) {
        </span><span style="color: #0000ff;">this</span>.A.heapSize += 1<span style="color: #000000;">;
        </span><span style="color: #0000ff;">this</span>.A[<span style="color: #0000ff;">this</span>.A.heapSize] =<span style="color: #000000;"> {
            x: x,
            priority: Infinity
        };
        Heap.decreasePriority(</span><span style="color: #0000ff;">this</span>.A, <span style="color: #0000ff;">this</span><span style="color: #000000;">.A.heapSize, priority);
    }

    pullLowestPriorityElement() {
        </span><span style="color: #0000ff;">if</span>(<span style="color: #0000ff;">this</span>.A.heapSize == 0<span style="color: #000000;">) {
            </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">null</span><span style="color: #000000;">;
        } </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
            </span><span style="color: #0000ff;">return</span> Heap.extractMin(<span style="color: #0000ff;">this</span><span style="color: #000000;">.A).x;
        }
    }

    peek() {
        </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">this</span>.A[1<span style="color: #000000;">].x;
    }
}

</span><span style="color: #008000;">//</span><span style="color: #008000;"> 改进版本3，专门用来写最小优先队列。</span><span style="color: #008000;">
//</span><span style="color: #008000;"> 每个数组元素有两个属性：x和priority，后者决定位置，前者是实际存储的内容</span>
<span style="color: #000000;">class Heap {
    </span><span style="color: #008000;">//</span><span style="color: #008000;"> 把数组A转化为最小堆</span>
<span style="color: #000000;">    static buildMinHeap(A) {
        A.unshift(undefined); </span><span style="color: #008000;">//</span><span style="color: #008000;"> 便于后续的下标计算</span>
<span style="color: #000000;">
        A.heapSize </span>= A.length - 1; <span style="color: #008000;">//</span><span style="color: #008000;"> 实际多存了一个undefined</span>
        <span style="color: #0000ff;">for</span>(let i = Math.floor(A.heapSize / 2); i &gt;= 1; --<span style="color: #000000;">i) {
            </span><span style="color: #008000;">//</span><span style="color: #008000;"> 对所有非叶结点调用一次minHeapify</span>
            <span style="color: #008000;">//</span><span style="color: #008000;"> 之所以下标从后往前，是因为minHeapify假定调用结点的左右子树都已经为最小堆</span>
            <span style="color: #008000;">//</span><span style="color: #008000;"> 单个元素（叶结点）很自然地是一个最小</span>
<span style="color: #000000;">            Heap.minHeapify(A, i);
        }
    }

    </span><span style="color: #008000;">//</span><span style="color: #008000;"> 维护堆的性质</span>
<span style="color: #000000;">    static minHeapify(A, i) {
        let l </span>=<span style="color: #000000;"> Heap.left(i);
        let r </span>=<span style="color: #000000;"> Heap.right(i);

        let smallest </span>=<span style="color: #000000;"> i;
        </span><span style="color: #008000;">//</span><span style="color: #008000;"> minHeapify假定调用结点的左右子树都已经为最小堆</span>
        <span style="color: #008000;">//</span><span style="color: #008000;"> 只是把调用结点i放到恰当的位置，以维护堆的性质</span>
        <span style="color: #0000ff;">if</span>(l &lt;= A.heapSize &amp;&amp; A[l].priority &lt;<span style="color: #000000;"> A[i].priority) {
            smallest </span>=<span style="color: #000000;"> l;
        }

        </span><span style="color: #0000ff;">if</span>(r &lt;= A.heapSize &amp;&amp; A[r].priority &lt;<span style="color: #000000;"> A[smallest].priority) {
            smallest </span>=<span style="color: #000000;"> r;
        }

        </span><span style="color: #0000ff;">if</span>(smallest !=<span style="color: #000000;"> i) {
            let temp </span>=<span style="color: #000000;"> A[i];
            A[i] </span>=<span style="color: #000000;"> A[smallest];
            A[smallest] </span>=<span style="color: #000000;"> temp;

            Heap.minHeapify(A, smallest);
        }
    }

    static left(i) {
        </span><span style="color: #0000ff;">return</span> 2 *<span style="color: #000000;"> i;
    }

    static right(i) {
        </span><span style="color: #0000ff;">return</span> 2 * i + 1<span style="color: #000000;">;
    }

    static parent(i) {
        </span><span style="color: #0000ff;">return</span> Math.floor(i / 2<span style="color: #000000;">);
    }

    static extractMin(A) {
        </span><span style="color: #0000ff;">if</span>(A.heapSize &lt; 1) <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">null</span><span style="color: #000000;">;

        let min </span>= A[1<span style="color: #000000;">];
        A[</span>1] =<span style="color: #000000;"> A[A.heapSize];
        A.heapSize </span>= A.heapSize - 1<span style="color: #000000;">;

        Heap.minHeapify(A, </span>1<span style="color: #000000;">);

        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> min;
    }

    static decreasePriority(A, i, newPriority) {
        </span><span style="color: #0000ff;">if</span>(newPriority &gt;<span style="color: #000000;"> A[i].priority) {
            </span><span style="color: #0000ff;">return</span><span style="color: #000000;">;
        }

        let temp </span>= A[i]; <span style="color: #008000;">//</span><span style="color: #008000;"> 待插入元素</span>
        temp.priority =<span style="color: #000000;"> newPriority;
        </span><span style="color: #0000ff;">while</span>(i &gt; 1 &amp;&amp; A[Heap.parent(i)].priority &gt;<span style="color: #000000;"> newPriority) {
            A[i] </span>=<span style="color: #000000;"> A[Heap.parent(i)];
            i </span>=<span style="color: #000000;"> Heap.parent(i);
        } </span><span style="color: #008000;">//</span><span style="color: #008000;"> 寻找合适的插入位置</span>
        A[i] = temp; <span style="color: #008000;">//</span><span style="color: #008000;"> 插入元素</span>
<span style="color: #000000;">    }
}</span></pre>
</div>
<span class="cnblogs_code_collapse">View Code</span></div>
<p>&nbsp;</p>