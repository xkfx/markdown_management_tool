<p><span class="md-expand">本文译自Shyam&nbsp;Balasubramanian所写的<strong>MavLink&nbsp;Tutorial&nbsp;for&nbsp;Absolute&nbsp;Dummies&nbsp;(Part&nbsp;&ndash;I)&nbsp;, 2013。</strong>仅供学习交流。</span><span class="md-expand"><span style="color: #ff0000;"><br /></span></span></p>
<div id="diy_right_menu">
<h2>索引</h2>
<ul><ol>
<li><a href="#anchor0">我为你而来，MavLink</a></li>
<li><a href="#anchor1">MavLink消息的结构：</a></li>
<li><a href="#anchor2">MavLink到底是如何工作的</a></li>
<li><a href="#anchor3">地面控制站（GCS）到四轴飞行器：</a></li>
<li><a href="#anchor4">四轴飞行器到地面控制站（GCS）到四轴飞行器：</a></li>


</ol></ul>


</div>
<p><span class="md-line md-end-block md-focus"><span class="md-expand"><strong>MavLink</strong><span>是什么鬼？它是一种通信协议。当看到这个概念后，大伙就开始畏惧它。这个教程将迫使你深刻地领悟它，并通俗易懂地阐述它究竟是什么，它是如何工作的，最重要的是它到底是如何工作的！！我将试着解释Mission Planner如何与APM/ PX4通信，反之亦然。这将有助于你的扩展，并激发你潜在的天才程序员天赋，如果你还没激发的话！！</span></span></span></p>
<p><span class="md-line md-end-block" style="color: #888888;">PS. Mission Planner是一款开源的无人机地面站软件，APM/ PX4则分别为两种飞控固件（类似于windows和linux的关系）。而pixhawk是飞控硬件，它可以安装上述两种固件中的任何一个。</span></p>
<p><span class="md-line md-end-block"><span>本教程假定：</span></span></p>
<ol class="ol-list" start="">
<li>
<p><span class="md-line md-end-block"><span>你是个小白☹我曾经也是，但现在不再是了!</span></span></p>


</li>
<li>
<p><span class="md-line md-end-block"><span>你至少在C语言方面具备一定的编程技能（例如，在C/C++/C#/Java中编写过简单的switch cases）。如果你已经是专业级，那么return 0;</span></span></p>


</li>
<li>
<p><span class="md-line md-end-block"><span>你很严肃地打算去学习知识，因为你将为此失去一些睡眠！</span></span></p>


</li>


</ol>
<p><span class="md-line md-end-block"><span>但不管怎样，请始终保持学习的意愿，我衷心希望你永远不会忘记这一点🙂我可以开始了吗？</span></span></p>
<h2><a name="anchor0"></a>我为你而来，MavLink</h2>
<p><span class="md-expand"><span class="md-expand">Mavlink消息基本上是由Mission Planner（MP）编码，并通过USB串行或遥测<span><strong><span>发送到APM</span></strong><span>的一串字节（两者不能同时使用。如果同时插入，则优先选择USB，而忽略遥测）。这里的<span><strong><span>编码</span></strong><span>并没有什么特别之处，只是把数据包放入一个数据结构中，然后通过信道以字节的形式发送出去，同时加上一些错误纠正。</span></span></span></span></span></span></p>
<h2><a name="anchor1"></a>MavLink消息的结构：</h2>
<p><span class="md-expand">每个MavLink数据包的长度为17字节，结构如下：</span></p>
<div class="cnblogs_code">
<pre>消息长度 = <span style="color: #800080;">17</span> (<span style="color: #800080;">6</span> bytes header + <span style="color: #800080;">9</span> bytes payload + <span style="color: #800080;">2</span> bytes checksum)</pre>
</div>
<div class="cnblogs_code">
<pre><span style="color: #000000;">长度为6个字节的首部 header
</span><span style="color: #800080;">0</span>. message header, 永远为 <span style="color: #800080;">0xFE</span>
<span style="color: #800080;">1</span>. message length (<span style="color: #800080;">9</span><span style="color: #000000;">)
</span><span style="color: #800080;">2</span>. sequence number -- 在 <span style="color: #800080;">255</span> 和 <span style="color: #800080;">0</span> 之间轮转(<span style="color: #800080;">0x4e</span>，前一个是 <span style="color: #800080;">0x4d</span><span style="color: #000000;">)
</span><span style="color: #800080;">3</span>. System ID - 什么系统在发送这个消息 (<span style="color: #800080;">1</span><span style="color: #000000;">)
</span><span style="color: #800080;">4</span>. Component ID- 系统的哪个组件正在发送消息 (<span style="color: #800080;">1</span><span style="color: #000000;">)
</span><span style="color: #800080;">5</span>. Message ID (例如 <span style="color: #800080;">0</span> = heartbeat 等等!<span style="color: #000000;"> 别害羞，你也可以添加..)

可变长的有效负载 Payload (由八位组构成, 范围是 </span><span style="color: #800080;">0</span>..<span style="color: #800080;">255</span><span style="color: #000000;">)
</span>**<span style="color: #000000;"> Payload (我们感兴趣的实际数据)

校验和 Checksum: 用于错误检测</span></pre>
</div>
<p><span class="md-line md-end-block md-focus" style="color: #888888;"><span class="md-expand">PS. &ldquo;由八位组构成&rdquo;在原文中是specified in octet 1</span></span></p>
<p><span class="md-line md-end-block"><span>（APM以及地面站）软件所做的事情是，检查它是否为一个有效的消息（通过检查Checksum判断消息是否已损坏，丢弃已经损坏的消息）。这是遥测的波特率为什么设置为57,600而不是115,200 bps的原因之一。该数值越低，软件容易发生的错误就越少，虽然消息更新到地面站的速度会慢一些。如果你想在采用MavLink协议的同时取得更远点的距离，进一步降低波特率可能是一个好主意。然而，需要注意的是，经过测试，57,600bps在理论上可以通过3DR遥测无线电提供大约一英里半径的覆盖范围。还记得高中时的信噪比（SNIR）的概念吗?</span></span></p>
<p><span class="md-line md-end-block"><span>现在，根据上面的内容，我们感兴趣的东西是：</span></span></p>
<ul class="ul-list" data-mark="*">
<li>
<p><span class="md-line md-end-block"><span>System ID（亦称消息的来源）：这是指通过无线遥测或USB端口向APM发送消息的发送源（也就是MP），软件会定期进行检查，以确认消息是发送给它的。</span></span></p>
</li>
<li>
<p><span class="md-line md-end-block"><span>Component ID （亦称系统中的子系统）：主系统中的任何子系统。目前，这里并没有子系统，我们也没有真正利用这个字段。</span></span></p>
</li>
<li>
<p><span class="md-line md-end-block"><span>Message ID：标识这是条关于什么的信息。在本教程中，我们将其称为&ldquo;主消息（main message）&rdquo;。</span></span></p>
</li>
<li>
<p><span class="md-line md-end-block"><span>Payload（实际数据）：这就是肉！这就是你想要的！！</span></span></p>
</li>
</ul>
<h2><a name="anchor2"></a>MavLink到底是如何工作的</h2>
<p><span class="md-line md-end-block md-focus"><span class="md-expand">MavLink啥也不是就是一条消息。MavLink也可以用于地面机器人，所以微型飞行器链路（Micro Aerial Vehicle Link，也就是MavLink） 并不是一个十分贴切的名字。之所以采取这种方式命名呢，是因为它起始于直升机（如果我没猜错的话）。</span></span></p>
<p><span class="md-line md-end-block"><span>&ldquo;消息&rdquo;是一个包含&ldquo;常量字节数&rdquo;（如前所述，即17字节）的数据包。APM（从空中）获取流字节，将其传输到硬件接口（例如，通过UART或遥测），并在软件中对消息进行解码。注意，<span><span style="text-decoration: underline;"><span><strong><span>消息</span></strong><span>包含着我们即将提取的有效负载（payload）</span></span></span><span>。</span></span></span></span></p>
<p><span class="md-line md-end-block"><span>我们对<span><strong>有效负载</strong><span>很感兴趣，但是，嘿，和有效负载在一起的是<span><strong>Message ID</strong><span>（见上面），<span><span style="text-decoration: underline;"><span>我们可以通过它了解<span><strong><span>有效负载</span></strong><span>代表着什么</span></span></span></span><span>。在这之前，先看看程序解释一切MavLink消息的几个步骤：</span></span></span></span></span></span></span></span></p>
<ol class="ol-list" start="">
<li>
<p><span class="md-line md-end-block"><span>我们有一个名为handlemessage (msg)的方法。这个就是你需要学习和了解的方法！在GCS_MavLink.pde中找到它（在Arducopter/ ArduPlane里）。</span></span></p>
<p><span class="md-line md-end-block" style="color: #888888;">PS. 该方法隶属APM固件的源代码。GCS_MavLink.pde现在似乎是这个<a href="https://github.com/ArduPilot/ardupilot/blob/8f550ffdd48a3165c115ca24d6ce5227a5f826d1/ArduCopter/GCS_Mavlink.cpp"><span style="color: #888888;">https://github.com/ArduPilot/ardupilot/blob/8f550ffdd48a3165c115ca24d6ce5227a5f826d1/ArduCopter/GCS_Mavlink.cpp</span></a></span></p>
<p><span class="md-line md-end-block"><span>它基本上是在问信息包：嘿，你是谁？你是为我而来还是试图侵入我的系统？在我给予你许可之前，让我先读一下你的<span><strong>系统ID和组件ID</strong><span>。<span><span style="text-decoration: underline;"><span>任何使用MavLink的系统都有一个系统ID和组件ID</span></span><span>。例如，你的MP和正在飞行的四轴飞行器将具有相同的系统ID。组件ID则用于附加到APM/PX4的&ldquo;子系统&rdquo;。</span></span></span></span></span></span></p>
<p><span class="md-line md-end-block"><span>注意：当前，系统ID和组件ID被<span><strong><span><span style="text-decoration: underline;"><span>硬编码</span></span></span></strong><span>为相同的。</span></span></span></span></p>
<p><span class="md-line md-end-block"><span>现在，你仅有一个遥测和一架安装了APM的直升机，就是这样，去愉快地飞行吧-不用再考虑其它的！这些东西对多直升机有帮助（在未来），未来将会有不同的系统ID🙂</span></span></p>
</li>
<li>
<p><span class="md-line md-end-block"><span>我们从消息中提取有效负载并放入一个<span><strong>包（packet）</strong><span>中。包是基于一种&ldquo;信息类型&rdquo;的数据结构。我们将不再使用&ldquo;消息&rdquo;一词，那玩意儿到这里就结束了。我们基本上只对由&ldquo;原始数据&rdquo;打包而成的包感兴趣。</span></span></span></span></p>
</li>
<li>
<p><span class="md-line md-end-block"><span>包被放入一个&ldquo;适当的数据结构&rdquo;中。有许多数据结构 ，例如用来存放姿态（俯仰，横摇，偏航方向）的、GPS的、无线电控制信道的，等等，也就是，把相似的东西组合在一起，形成易于理解的模块。这些数据结构在发送端和接收端（即在MP端和APM端）<span><strong>&ldquo;100%完全相同&rdquo;</strong><span>。 如果不一样的话，你的直升机就会在奇怪的时间坠毁！</span></span></span></span></p>
</li>
</ol>
<p><span class="md-line md-end-block" style="color: #888888;">PS. 无线电控制信道原文中为RC channel</span></p>
<p><span class="md-line md-end-block"><span>此外，这也是MavLink GUI生成器大展身手的地方。为了生成这些数据结构，我们不需要编写任何代码！！嗯，也不完全是，但只有一点点。</span></span></p>
<p><span class="md-line md-end-block"><span>到目前为止很简单对不对？如果觉得困难请重读一遍！！当个笨蛋没关系的🙂</span></span></p>
<p><span class="md-line md-end-block"><span>好了，现在说正事。我们使用MavLink发送双向消息。</span></span></p>
<blockquote>
<p><span class="md-line md-end-block">从地面控制站（GCS）到APM/PX4或从APM/PX4到地面控制站（GCS）。注意，我说的GCS是指Mission Planner（MP）或者QGroundControl（QGC）、DroidPlanner（DP）或者你自定义的与直升机通信的工具。</span></p>
</blockquote>
<h2><a name="anchor3"></a>地面控制站（GCS）到四轴飞行器：</h2>
<p><span class="md-line md-end-block md-focus"><span class="md-expand">到目前为止，我们知道每个消息（我们叫一个包，里面有对我们有用的信息）都有一个消息ID和有效负载，并将其放入适当类型的数据结构中。我们根据主消息（或MAVLINK_MSG_ID_）进行选择，一旦检测到特定类型的消息，就会执行一些神奇的操作，比如将接收到的信息存储到永久内存中，或者执行我们希望对其执行的任何操作。</span></span></p>
<p><span class="md-line md-end-block"><span>截至2013年11月，在Arducopter最新的3.0.1 RC5（候选版本）中，以下是你可能看到的参数。我已经试着列出所有可能的MavLink消息的&ldquo;主消息&rdquo;ID。</span></span></p>
<p><span class="md-line md-end-block"><span>请注意，在每个&ldquo;主消息&rdquo;类别中（如粗体部分下面的东西）你会找到属于那个类别的&ldquo;子消息&rdquo;，它们基本上与有效负载信息（真正的肉）及其处理方式密切相关。就像&ldquo;自行车&rdquo;类别有雅马哈，铃木，哈雷戴维森等。我列出了所有的主要信息类别，但只指定了一些子类别。你可以自己查一下细节🙂因为如果你明白我到目前为止的意思，你就不再是个傻瓜了。明白我的意思吗？</span></span></p>
<p><span class="md-line md-end-block" style="color: #888888;">PS. 因为下面的部分，准确含义并不太清楚，所以只选了若干个翻译。欲看每个条目的详情可查看原文：<a href="https://diydrones.com/forum/topics/mavlink-tutorial-for-absolute-dummies-part-i?groupUrl=arducopterusergroup"><span style="color: #888888;">https://diydrones.com/forum/topics/mavlink-tutorial-for-absolute-dummies-part-i?groupUrl=arducopterusergroup</span></a></span></p>
<p><span class="md-line md-end-block md-focus"><span class="md-expand"><strong>MAVLINK_MSG_ID</strong><span>（主消息块）：</span></span></span></p>
<ol class="ol-list" start="">
<li>
<p><span class="md-line md-end-block"><span>MAVLINK_MSG_ID_HEARTBEAT：//0</span></span></p>
<p><span class="md-line md-end-block"><span>这是<span><strong>最重要的信息</strong><span>。GCS不断地向APM/PX4发送信息，以确定它是否与之相连（每1秒一次）。这是为了确保在更新某些参数时MP与APM是同步的。如果错过了许多心跳信号，则会触发故障保护（可能），接着直升机可能着陆、继续执行任务或返回发射（Returns to launch，也称为RTL）。在MP的&ldquo;配置/设置故障保护选项&rdquo;下，可以启用/禁用故障保护选项。但你不能停止心跳，对吗？这个名字很有道理！!</span></span></span></span></p>
</li>
<li>
<p><span class="md-line md-end-block"><span>MAVLINK_MSG_ID_REQUEST_DATA_STREAM：//66</span></span></p>
<p><span class="md-line md-end-block"><span>请求传感器，无线电控制信道，GPS位置，状态，Extra 1/2/3 等数据</span></span></p>
</li>
<li>
<p><span class="md-line md-end-block"><span>MAVLINK_MSG_ID_COMMAND_LONG：//76 </span></span></p>
<p><span class="md-line md-end-block"><span>无限制悬停（Loiter unlimited），RTL，着陆，任务开始（Mission start），飞控解锁/锁定（Arm/Disarm ），重新启动（Reboot）。</span></span></p>
<p><span class="md-line md-end-block" style="color: #888888;">PS. 例如在航前检查未通过时是禁止直接用commander arm对飞控解锁的。</span></p>
</li>
<li>
<p><span class="md-line md-end-block"><span>SET_MODE： //11 </span></span></p>
<p><span class="md-line md-end-block"><span>E.g. set_mode(packet.custom_mode); </span></span></p>
</li>
<li>
<p><span class="md-line md-end-block"><span>MAVLINK_MSG_ID_MISSION_REQUEST_LIST： //43 </span></span></p>
</li>
<li>
<p><span class="md-line md-end-block"><span>MAVLINK_MSG_ID_MISSION_REQUEST： //40 </span></span></p>
</li>
<li>
<p><span class="md-line md-end-block"><span>MAVLINK_MSG_ID_MISSION_ACK： //47 </span></span></p>
</li>
<li>
<p><span class="md-line md-end-block"><span>MAVLINK_MSG_ID_PARAM_REQUEST_LIST： //21 </span></span></p>
</li>
<li>
<p><span class="md-line md-end-block"><span>MAVLINK_MSG_ID_PARAM_REQUEST_READ： //20 </span></span></p>
</li>
<li>
<p><span class="md-line md-end-block"><span>MAVLINK_MSG_ID_MISSION_CLEAR_ALL： //45 </span></span></p>
</li>
<li>
<p><span class="md-line md-end-block"><span>MAVLINK_MSG_ID_MISSION_SET_CURRENT： //41 </span></span></p>
</li>
<li>
<p><span class="md-line md-end-block"><span>MAVLINK_MSG_ID_MISSION_COUNT： // 44 </span></span></p>
</li>
<li>
<p><span class="md-line md-end-block"><span>MAVLINK_MSG_ID_MISSION_WRITE_PARTIAL_LIST： // </span></span></p>
</li>
<li>
<p><span class="md-line md-end-block"><span>MAVLINK_MSG_ID_SET_MAG_OFFSETS： //151 </span></span></p>
</li>
<li>
<p><span class="md-line md-end-block"><span>MAVLINK_MSG_ID_MISSION_ITEM： //39</span></span></p>
</li>
<li class="md-focus-container">
<p><span class="md-line md-end-block md-focus"><span class="md-expand">MAVLINK_MSG_ID_PARAM_SET： //23 </span></span></p>
</li>
<li>
<p><span class="md-line md-end-block"><span>MAVLINK_MSG_ID_RC_CHANNELS_OVERRIDE： //70 </span></span></p>
</li>
<li>
<p><span class="md-line md-end-block"><span>MAVLINK_MSG_ID_HIL_STATE： //90 </span></span></p>
</li>
<li>
<p><span class="md-line md-end-block"><span>MAVLINK_MSG_ID_DIGICAM_CONFIGURE： // </span></span></p>
</li>
<li>
<p><span class="md-line md-end-block"><span>MAVLINK_MSG_ID_MOUNT_CONFIGURE： // </span></span></p>
</li>
<li>
<p><span class="md-line md-end-block"><span>MAVLINK_MSG_ID_MOUNT_CONTROL： // </span></span></p>
</li>
<li>
<p><span class="md-line md-end-block"><span>MAVLINK_MSG_ID_MOUNT_STATUS：// </span></span></p>
</li>
<li>
<p><span class="md-line md-end-block"><span>MAVLINK_MSG_ID_RADIO, MAVLINK_MSG_ID_RADIO_STATUS： //</span></span></p>
</li>
</ol>
<h2><a name="anchor4"></a>四轴飞行器到地面控制站（GCS）到四轴飞行器：</h2>
<p><span class="md-line md-end-block md-focus"><span class="md-expand">好吧，我承认，这变得更有趣了。但这其实容易得多。事实上，GCS系统只是你和直升机之间的中介物，它反过来从直升机获取数据，并显示在GCS系统上。</span></span></p>
<p><span class="md-line md-end-block"><span>如果你打开了Arducopter.pde文件，请查看代码的这一部分：</span></span></p>
<p><span class="md-line md-end-block" style="color: #888888;">PS. Arducopter.pde现在似乎是这个<a href="https://github.com/ArduPilot/ardupilot/blob/master/ArduCopter/Copter.cpp"><span style="color: #888888;">https://github.com/ArduPilot/ardupilot/blob/master/ArduCopter/Copter.cpp</span></a></span></p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">static</span> <span style="color: #0000ff;">const</span> AP_Scheduler::Task scheduler_tasks[] PROGMEM =<span style="color: #000000;"> {
. . .
. . .
{ gcs_send_heartbeat, </span><span style="color: #800080;">100</span>, <span style="color: #800080;">150</span><span style="color: #000000;"> },
{ update_notify, </span><span style="color: #800080;">2</span>, <span style="color: #800080;">100</span><span style="color: #000000;"> },
{ one_hz_loop, </span><span style="color: #800080;">100</span>, <span style="color: #800080;">420</span><span style="color: #000000;"> },
{ gcs_check_input, </span><span style="color: #800080;">2</span>, <span style="color: #800080;">550</span><span style="color: #000000;"> },
{ gcs_send_heartbeat, </span><span style="color: #800080;">100</span>, <span style="color: #800080;">150</span><span style="color: #000000;"> },
{ gcs_send_deferred, </span><span style="color: #800080;">2</span>, <span style="color: #800080;">720</span><span style="color: #000000;"> },
{ gcs_data_stream_send, </span><span style="color: #800080;">2</span>, <span style="color: #800080;">950</span><span style="color: #000000;"> },
. . .
. . .
. . .</span></pre>
</div>
<p><span class="md-line md-end-block md-focus"><span class="md-expand">别害怕。这比呼吸还容易。这就是<span><strong>实时系统</strong><span>概念发挥作用的地方。我们希望确定的任务花费确定的时间，如果到了规定的时间任务仍没完成，就不再继续执行它们了。</span></span></span></span></p>
<p><span class="md-line md-end-block"><span>第一个参数是函数名，</span></span></p>
<p><span class="md-line md-end-block"><span>第二个是&ldquo;它应该花费的时间&rdquo;（以10毫秒为单位，例如2表示20毫秒执行一次，即50赫兹，即该功能每秒运行50次）。</span></span></p>
<p><span class="md-line md-end-block" style="color: #888888;">PS. 1s = 1000ms 故 1000 / 20 = 50 ms/次 = 50Hz</span></p>
<p><span class="md-line md-end-block"><span>第三个参数是&ldquo;最长执行时间，超出该时间函数就不应继续运行&rdquo;。</span></span></p>
<p><span class="md-line md-end-block"><span>我觉得这很简单！你在这里看到的每一个函数，它的未来都是确定的，运行时间都是一成不变的。这就是为什么我们在这些讨厌的机器上采用实时系统，这可以保证它的安全，让其变得可预测而不是不可预测！！</span></span></p>
<p><span class="md-line md-end-block"><span>所有这些函数都是为你精心挑选的，以便让你知道它们与GCS系统的更新相关。简单地说，进入每一个函数的定义，这些函数将始终可以在GCS_Mavlink.pde中找到，在那里GCS系统通信的实际操作发生了！!</span></span></p>
<p><span class="md-line md-end-block"><span>最有趣（也是最重要）的是：</span></span></p>
<div class="cnblogs_code">
<pre><span style="color: #008000;">/*</span><span style="color: #008000;">
* send data streams in the given rate range on both links
</span><span style="color: #008000;">*/</span>
<span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span> gcs_data_stream_send(<span style="color: #0000ff;">void</span><span style="color: #000000;">)
{
    gcs0.data_stream_send();
    </span><span style="color: #0000ff;">if</span><span style="color: #000000;"> (gcs3.initialised) {
        gcs3.data_stream_send();
    }
}</span></pre>
</div>
<p><span class="md-line md-end-block md-focus"><span class="md-expand">上面所做的事情是，通过链路发送数据（gcs0表示通过USB，gcs3表示通过遥测）。如果你再深入一点，你就会知道，我们会把这些数据结构发送回GCS系统显示。</span></span></p>
<p><span class="md-line md-end-block"><span>例如，当你用手移动你的直升机时，瞧瞧MP的HUD屏幕发生了什么？你将看到直升机在屏幕上移动。并且，我们得到了每个时间单位的飞行姿态数据（俯仰、横摇和偏航）。同样，我们还可以看到IMU数据、GPS数据、电池数据等。</span></span></p>